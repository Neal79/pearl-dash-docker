/**
 * useHlsVideo.ts - HLS Video Stream Management Composable
 * 
 * HLS VIDEO STREAMING OPTIMIZATION (January 2025):
 * ===============================================
 * This composable enables bandwidth-efficient HLS video streaming by leveraging optimized
 * dual-output FFmpeg streams from the audio meter service. Eliminates duplicate RTSP connections.
 * 
 * BANDWIDTH OPTIMIZATION ARCHITECTURE:
 * ===================================
 * - BEFORE: Separate RTSP streams for audio meters + video = 2x bandwidth usage
 * - AFTER: Single RTSP stream serves both audio meters + HLS video = 50% bandwidth savings
 * - Uses shared HLS segments generated by audio-meter-service dual-output FFmpeg
 * - No additional load on Pearl devices (hardware encoders, not servers)
 * 
 * LAN-OPTIMIZED PERFORMANCE:
 * =========================
 * Designed for local network deployment (users typically one switch away):
 * - 4-5 second startup delay (reasonable for LAN)
 * - 4-second HLS segments with 24-second buffer (anti-jitter)
 * - Fast retry logic (500ms delays, sufficient for LAN reliability)
 * - Immediate loading without pre-buffering delays
 * 
 * HLS.JS CONFIGURATION:
 * ====================
 * - LAN-tuned buffering: 10-20 second buffers (vs typical 30+ for WAN)
 * - Native HLS support (Safari) with HLS.js fallback (Chrome, Firefox)
 * - Dynamic imports to avoid bundle bloat when video not used
 * - Buffer monitoring and stall recovery for smooth playback
 * 
 * LARAVEL INTEGRATION:
 * ===================
 * - Stream URLs: `/api/devices/{device}/channels/{channel}/hls/stream.m3u8`
 * - Laravel serves local HLS files from shared Docker volume (not Pearl device proxy)
 * - Authentication and CORS headers managed server-side
 * - Segment URL rewriting for proper web browser access
 * 
 * RACE CONDITION PREVENTION:
 * =========================
 * - Graceful retry logic with exponential backoff for segment availability
 * - Handles timing issues when HLS segments are still being generated
 * - UI integration with 3-second disabled state on channel changes
 * 
 * RESOURCE MANAGEMENT:
 * ===================
 * - Video streams loaded only when video mode is active
 * - Automatic cleanup when switching back to image mode
 * - Channel changes automatically cleanup previous streams
 * - No background loading or prefetching (bandwidth conservation)
 * 
 * AUDIO/VIDEO SYNC:
 * ================
 * - Relies on FFmpeg timestamp preservation (`-copyts`, `-avoid_negative_ts disabled`)
 * - Respects Pearl device's original H.264 timing (no forced frame rates)
 * - Sync issues in test environments may be due to looping video, not production Pearl devices
 */

import { ref, computed, onBeforeUnmount, watch, nextTick } from 'vue'
import type { Ref } from 'vue'

interface HlsVideoOptions {
  device: string // Device IP
  channel: number // Channel ID
  autoStart?: boolean // Auto-start video on init
}

interface HlsVideoState {
  isLoaded: Ref<boolean>
  isPlaying: Ref<boolean>
  isMuted: Ref<boolean>
  isFullscreen: Ref<boolean>
  error: Ref<string | null>
  streamUrl: Ref<string | null>
}

interface HlsVideoMethods {
  loadStream: (videoElement: HTMLVideoElement) => Promise<boolean>
  unloadStream: () => void
  play: () => Promise<void>
  pause: () => void
  toggleMute: () => void
  toggleFullscreen: (videoElement: HTMLVideoElement) => Promise<void>
  destroy: () => void
}

export type HlsVideoComposable = HlsVideoState & HlsVideoMethods

export function useHlsVideo(options: HlsVideoOptions): HlsVideoComposable {
  // Reactive state
  const isLoaded = ref(false)
  const isPlaying = ref(false)
  const isMuted = ref(true) // Start muted like audio streaming
  const isFullscreen = ref(false)
  const error = ref<string | null>(null)
  
  // HLS instance and video element references
  let hlsInstance: any = null
  let videoElement: HTMLVideoElement | null = null
  
  // Construct stream URL - points to Laravel HLS proxy (not direct Pearl device)
  const streamUrl = computed(() => {
    if (!options.device || !options.channel) return null
    // IMPORTANT: Uses Laravel proxy endpoint, not direct Pearl device URL
    // This ensures authentication, CORS headers, and segment URL rewriting
    // Laravel proxy format: /api/devices/{device_id}/channels/{channel}/hls/stream.m3u8
    // Note: Hard-coded device ID 1 - in production this should use actual device lookup
    return `/api/devices/1/channels/${options.channel}/hls/stream.m3u8`
  })
  
  console.log(`ðŸŽ¥ HLS Video composable initialized for ${options.device}:${options.channel}`)
  
  /**
   * Load HLS stream into video element with retry logic for timing issues
   */
  const loadStream = async (videoEl: HTMLVideoElement): Promise<boolean> => {
    if (!streamUrl.value) {
      error.value = 'No stream URL available'
      return false
    }
    
    // First check if HLS files exist - retry with exponential backoff
    const streamAvailable = await waitForHlsStream()
    if (!streamAvailable) {
      return false
    }
    
    try {
      console.log(`ðŸŽ¥ Loading HLS stream: ${streamUrl.value}`)
      error.value = null
      videoElement = videoEl
      
      // Check if HLS is supported natively (Safari)
      if (videoEl.canPlayType('application/vnd.apple.mpegurl')) {
        console.log('ðŸŽ¥ Using native HLS support with aggressive buffering')
        
        // Configure HTML5 video for maximum buffering
        videoEl.preload = 'auto' // Preload as much as possible
        videoEl.setAttribute('x-webkit-airplay', 'allow')
        
        // Set buffer preferences for Safari
        if ('webkitSetMediaKeys' in videoEl) {
          // Safari-specific buffer hints
          (videoEl as any).webkitPreservesPitch = false
        }
        
        videoEl.src = streamUrl.value
        
        // For native HLS, load immediately without waiting
        console.log('âœ… Native HLS loaded - starting immediately')
        isLoaded.value = true
        
        return true
      } 
      // Use HLS.js for browsers that don't support HLS natively
      else {
        // Dynamically import HLS.js to avoid bundle bloat
        const Hls = (await import('hls.js')).default
        
        if (Hls.isSupported()) {
          console.log('ðŸŽ¥ Using HLS.js for stream playback')
          
          hlsInstance = new Hls({
            debug: false,
            enableWorker: true,
            lowLatencyMode: false, // Pearl Mini streams aren't ultra low latency
            
            // LAN-optimized buffering (4-6 second target delay)
            backBufferLength: 10, // Keep 10 seconds of back buffer (reasonable for LAN)
            maxBufferLength: 20, // Max 20 seconds buffer (10x segment buffer)
            maxBufferSize: 30 * 1000 * 1000, // 30MB max buffer size (reasonable for LAN)
            maxBufferHole: 0.3, // Allow 300ms buffer holes (tight for LAN)
            
            // Fast fragment loading for LAN
            fragLoadingTimeOut: 10000, // 10s timeout (reasonable for LAN)
            fragLoadingMaxRetry: 3, // 3 retries (sufficient for LAN)
            fragLoadingRetryDelay: 500, // 500ms delay between retries
            
            // Level/quality management
            startLevel: -1, // Auto-select initial quality
            capLevelToPlayerSize: false, // Don't limit quality to player size
            
            // LAN-appropriate live sync (4-6 second delay)
            liveSyncDuration: 2, // 2 segments for live sync (4s delay - good for LAN)
            liveMaxLatencyDuration: 8, // Max 8s latency before sync correction
            liveDurationInfinity: false, // Don't allow infinite buffer growth
            
            // Standard error recovery
            enableSoftwareAES: true, // Software AES fallback
            testBandwidth: false, // Skip initial bandwidth test
            
            // Minimal startup buffering for LAN
            startFragPrefetch: true, // Pre-fetch fragments
            initialLiveManifestSize: 2, // Load 2 segments initially (4s startup buffer)
          })
          
          // Error handling
          hlsInstance.on(Hls.Events.ERROR, (event: any, data: any) => {
            console.error('ðŸŽ¥ HLS.js error:', data)
            if (data.fatal) {
              switch (data.type) {
                case Hls.ErrorTypes.NETWORK_ERROR:
                  error.value = 'Network error loading video stream'
                  break
                case Hls.ErrorTypes.MEDIA_ERROR:
                  error.value = 'Media error in video stream'
                  break
                default:
                  error.value = 'Fatal error loading video stream'
                  break
              }
            }
          })
          
          // Success events - load immediately without pre-buffering
          hlsInstance.on(Hls.Events.MANIFEST_LOADED, () => {
            console.log('âœ… HLS manifest loaded - starting immediately')
            isLoaded.value = true
          })
          
          // Buffer monitoring for jitter detection (simplified)
          hlsInstance.on(Hls.Events.BUFFER_APPENDED, (event: any, data: any) => {
            // Log buffer health for debugging
            if (hlsInstance && videoElement) {
              const bufferInfo = hlsInstance.getBufferLength()
              console.log(`ðŸŽ¥ Buffer: ${bufferInfo.toFixed(1)}s`)
            }
          })
          
          // Handle buffer stalls
          hlsInstance.on(Hls.Events.BUFFER_STALLED, () => {
            console.warn('âš ï¸ Buffer stalled - attempting recovery')
            // HLS.js will automatically try to recover
          })
          
          // Monitor for smooth playback
          hlsInstance.on(Hls.Events.FRAG_LOADED, (event: any, data: any) => {
            // Ensure continuous playback by checking for gaps
            if (videoElement && !videoElement.paused) {
              const currentTime = videoElement.currentTime
              const buffered = videoElement.buffered
              
              // Check for buffer gaps that could cause jitter
              for (let i = 0; i < buffered.length; i++) {
                const start = buffered.start(i)
                const end = buffered.end(i)
                
                if (currentTime >= start && currentTime < end) {
                  // We're in a buffered range - good
                  break
                } else if (i === buffered.length - 1) {
                  // We're not in any buffered range - potential stall
                  console.warn('âš ï¸ Playback position outside buffered ranges')
                }
              }
            }
          })
          
          // Load the stream
          hlsInstance.loadSource(streamUrl.value)
          hlsInstance.attachMedia(videoEl)
          
          return true
        } else {
          error.value = 'HLS not supported by this browser'
          return false
        }
      }
    } catch (err) {
      console.error('ðŸŽ¥ Error loading HLS stream:', err)
      error.value = 'Failed to load video stream'
      return false
    }
  }

  /**
   * Wait for HLS stream to be available with exponential backoff retry
   * Handles timing issues when HLS segments are still being generated
   */
  const waitForHlsStream = async (): Promise<boolean> => {
    const maxRetries = 12 // ~15 seconds total wait time
    let retryCount = 0
    
    console.log('ðŸŽ¥ Checking HLS stream availability...')
    
    while (retryCount < maxRetries) {
      try {
        // Test if HLS playlist is available
        const response = await fetch(streamUrl.value!, {
          method: 'HEAD', // Just check if file exists, don't download
          cache: 'no-cache'
        })
        
        if (response.ok) {
          console.log(`âœ… HLS stream available after ${retryCount} retries`)
          return true
        }
        
        // 404 means files aren't ready yet, other errors are real problems
        if (response.status !== 404) {
          console.error(`ðŸŽ¥ HLS stream error: ${response.status} ${response.statusText}`)
          error.value = `Stream unavailable: ${response.statusText}`
          return false
        }
        
      } catch (err) {
        console.log(`ðŸŽ¥ Retry ${retryCount + 1}: Stream not ready yet`)
      }
      
      // Exponential backoff: 300ms, 450ms, 675ms, 1000ms, 1500ms, 2000ms (max)
      const baseDelay = 300
      const delay = Math.min(baseDelay * Math.pow(1.5, retryCount), 2000)
      
      console.log(`â³ Waiting ${delay}ms before retry ${retryCount + 1}/${maxRetries}...`)
      await new Promise(resolve => setTimeout(resolve, delay))
      
      retryCount++
    }
    
    console.error('âŒ HLS stream not available after maximum retries')
    error.value = 'Video stream timed out. Audio meters must be active for video streaming.'
    return false
  }
  
  /**
   * Unload stream and cleanup resources
   */
  const unloadStream = () => {
    console.log('ðŸŽ¥ Unloading HLS stream')
    
    if (hlsInstance) {
      hlsInstance.destroy()
      hlsInstance = null
    }
    
    if (videoElement) {
      videoElement.src = ''
      videoElement.load()
      videoElement = null
    }
    
    isLoaded.value = false
    isPlaying.value = false
    error.value = null
    
    console.log('âœ… HLS stream unloaded and resources cleaned up')
  }
  
  /**
   * Play video
   */
  const play = async (): Promise<void> => {
    if (!videoElement || !isLoaded.value) return
    
    try {
      await videoElement.play()
      isPlaying.value = true
      console.log('âœ… Video playback started')
    } catch (err) {
      console.error('ðŸŽ¥ Error starting video playback:', err)
      error.value = 'Failed to start video playback'
    }
  }
  
  /**
   * Pause video
   */
  const pause = (): void => {
    if (!videoElement) return
    
    videoElement.pause()
    isPlaying.value = false
    console.log('â¸ï¸ Video playback paused')
  }
  
  /**
   * Toggle video mute (independent of audio streaming)
   */
  const toggleMute = (): void => {
    if (!videoElement) return
    
    isMuted.value = !isMuted.value
    videoElement.muted = isMuted.value
    
    console.log(`ðŸŽ¥ Video ${isMuted.value ? 'muted' : 'unmuted'}`)
  }
  
  /**
   * Toggle fullscreen
   */
  const toggleFullscreen = async (videoEl: HTMLVideoElement): Promise<void> => {
    try {
      if (!isFullscreen.value) {
        // Enter fullscreen
        if (videoEl.requestFullscreen) {
          await videoEl.requestFullscreen()
        }
        isFullscreen.value = true
      } else {
        // Exit fullscreen
        if (document.exitFullscreen) {
          await document.exitFullscreen()
        }
        isFullscreen.value = false
      }
    } catch (err) {
      console.error('ðŸŽ¥ Error toggling fullscreen:', err)
    }
  }
  
  /**
   * Complete cleanup and destroy
   */
  const destroy = (): void => {
    console.log('ðŸŽ¥ Destroying HLS video composable')
    unloadStream()
  }
  
  // Handle fullscreen change events
  const handleFullscreenChange = () => {
    isFullscreen.value = !!document.fullscreenElement
  }
  
  // Add fullscreen event listener
  if (typeof document !== 'undefined') {
    document.addEventListener('fullscreenchange', handleFullscreenChange)
  }
  
  // Cleanup on unmount
  onBeforeUnmount(() => {
    console.log('ðŸŽ¥ HLS video composable unmounting - cleaning up resources')
    destroy()
    
    if (typeof document !== 'undefined') {
      document.removeEventListener('fullscreenchange', handleFullscreenChange)
    }
  })
  
  return {
    // State
    isLoaded,
    isPlaying,
    isMuted,
    isFullscreen,
    error,
    streamUrl,
    
    // Methods
    loadStream,
    unloadStream,
    play,
    pause,
    toggleMute,
    toggleFullscreen,
    destroy
  }
}

export default useHlsVideo